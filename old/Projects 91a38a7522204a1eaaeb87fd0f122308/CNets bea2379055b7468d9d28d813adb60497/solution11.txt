#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define COLS 3
#define ROWS 3

int** solution11v1(int** m1, int** m2) {

    // Write a C program to multiply two 3x3 matrix using pointers
    // (Dynamic allocation with pointers to pointers)

    // Step #1: create the "res" matrix to be returned
    
    int** res = malloc(ROWS * sizeof(int*)); // Notice: you do a loop over the res[i].

    for (int i = 0; i < ROWS; i++) {
        *(res + i) = malloc(COLS * sizeof(int));
    }
    // Step #2: compute the values of the res function and store them
    
    for (int i = 0; i < ROWS; i++){
        for (int j = 0; j < COLS; j++){
            *(*(res + i) + j) = 0;
            for (int k = 0; k < COLS; k++){
                *(*(res + i) + j) += *(*(m1 + i) + k) * *(*(m2 + k) + j); 
            }
        }
    }
    return res;
}

int (*solution11v2v1(int (*m1)[COLS], int (*m2)[COLS]))[COLS] {

    // Write a C program to multiply two 3x3 matrix using pointers
    // (Simulated 2D array, single allocation for a contiguous block)

    // Step #1: create the "res" matrix to be returned

    int (*res)[COLS] = malloc(ROWS * sizeof(*res)); // Notice: no need to do a loop and do a malloc in res[i].

    // Step #2: compute the values of the res function and store them

    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            res[i][j] = 0;
            for (int k = 0; k < COLS; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }

    return res;
}

int (*solution11v2v2(int (*m1)[COLS], int (*m2)[COLS]))[COLS] {
    
    // Write a C program to multiply two 3x3 matrix using pointers
    // (Simulated 2D array, single allocation for a contiguous block)
    
    // Step #1: create the "res" matrix to be returned
    int (*res)[COLS] = malloc(ROWS * sizeof(*res));
    
    // Step #2: compute the values of the res function and store them using pointer arithmetic
    int *pRes = &res[0][0];  // Pointer to the start of res
    int *pM1 = &m1[0][0];    // Pointer to the start of m1
    int *pM2 = &m2[0][0];    // Pointer to the start of m2
    
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            *pRes = 0;  // Initialize the element to 0
            int *pM1Row = pM1 + i * COLS;  // Pointer to the start of the current row in m1
            int *pM2Col = pM2 + j;         // Pointer to the start of the current column in m2
            
            for (int k = 0; k < COLS; k++) {
                *pRes += *pM1Row * *pM2Col;
                pM1Row++;      // Move to the next element in the row of m1
                pM2Col += COLS;  // Move to the next element in the column of m2
            }
            pRes++;  // Move to the next element in res
        }
    }
    
    return res;
}

typedef struct {
    int rows;
    int cols;
    int** data;
} Matrix;

Matrix solution11v3v1(Matrix m1, Matrix m2) {

    // Write a C program to multiply two matrix using pointers
    // (Return a struct containing the matrix and its dimensions)

    // Check if matrices can be multiplied
    if (m1.cols != m2.rows) {
        // Return an "error" matrix
        return (Matrix){0, 0, NULL};
    }

    // Step #1: create the "res" matrix to be returned
    Matrix res = {m1.rows, m2.cols, malloc(m1.rows * sizeof(int*))};

    for (int i = 0; i < m1.rows; i++) {
        *(res.data + i) = malloc(m2.cols * sizeof(int));
    }

    // Step #2: compute the values of the res function and store them
    for (int i = 0; i < m1.rows; i++){
        for (int j = 0; j < m2.cols; j++){
            *(*(res.data + i) + j) = 0;
            for (int k = 0; k < m1.cols; k++){
                *(*(res.data + i) + j) += *(*(m1.data + i) + k) * *(*(m2.data + k) + j); 
            }
        }
    }

    return res;
}

Matrix* solution11v3v2(const Matrix* m1, const Matrix* m2) {

    // Write a C program to multiply two matrix using pointers
    // (Return a POINTER TO a struct containing the matrix and its dimensions)

    // Check if matrices can be multiplied
    if (m1->cols != m2->rows) {
        return NULL;
    }

    // Step #1: create the "res" matrix to be returned
    Matrix* res = malloc(sizeof(Matrix));
    res->rows = m1->rows;
    res->cols = m2->cols;
    res->data = malloc(res->rows * sizeof(int*));
    for (int i = 0; i < res->rows; i++) {
        res->data[i] = malloc(res->cols * sizeof(int));
    }

    // Step #2: compute the values of the res function and store them
    for (int i = 0; i < m1->rows; i++) {
        for (int j = 0; j < m2->cols; j++) {
            res->data[i][j] = 0;
            for (int k = 0; k < m1->cols; k++) {
                res->data[i][j] += m1->data[i][k] * m2->data[k][j];
            }
        }
    }

    return res;
}

// Function prototypes (copy all the function definitions from the original code here)

void print_matrix(int rows, int cols, int **matrix) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

void print_matrix_2d(int rows, int cols, int (*matrix)[cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

void print_matrix_struct(Matrix matrix) {
    for (int i = 0; i < matrix.rows; i++) {
        for (int j = 0; j < matrix.cols; j++) {
            printf("%d ", matrix.data[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    // Initialize test matrices
    int **m1 = malloc(ROWS * sizeof(int*));
    int **m2 = malloc(ROWS * sizeof(int*));
    for (int i = 0; i < ROWS; i++) {
        m1[i] = malloc(COLS * sizeof(int));
        m2[i] = malloc(COLS * sizeof(int));
        for (int j = 0; j < COLS; j++) {
            m1[i][j] = i * COLS + j + 1;
            m2[i][j] = (i * COLS + j + 1) * 2;
        }
    }

    // Initialize test matrices for v2 functions
    int m1_2d[ROWS][COLS];
    int m2_2d[ROWS][COLS];
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            m1_2d[i][j] = i * COLS + j + 1;
            m2_2d[i][j] = (i * COLS + j + 1) * 2;
        }
    }

    // Test solution11v1
    printf("Result of solution11v1:\n");
    int **res1 = solution11v1(m1, m2);
    print_matrix(ROWS, COLS, res1);

    // Test solution11v2v1
    printf("Result of solution11v2v1:\n");
    int (*res2)[COLS] = solution11v2v1(m1_2d, m2_2d);
    print_matrix_2d(ROWS, COLS, res2);

    // Test solution11v2v2
    printf("Result of solution11v2v2:\n");
    int (*res3)[COLS] = solution11v2v2(m1_2d, m2_2d);
    print_matrix_2d(ROWS, COLS, res3);

    // Test solution11v3v1
    Matrix matrix1 = {ROWS, COLS, m1};
    Matrix matrix2 = {ROWS, COLS, m2};
    printf("Result of solution11v3v1:\n");
    Matrix res4 = solution11v3v1(matrix1, matrix2);
    print_matrix_struct(res4);

    // Test solution11v3v2
    printf("Result of solution11v3v2:\n");
    Matrix *res5 = solution11v3v2(&matrix1, &matrix2);
    print_matrix_struct(*res5);

    // Free allocated memory
    for (int i = 0; i < ROWS; i++) {
        free(m1[i]);
        free(m2[i]);
        free(res1[i]);
    }
    free(m1);
    free(m2);
    free(res1);
    free(res2);
    free(res3);
    for (int i = 0; i < res4.rows; i++) {
        free(res4.data[i]);
    }
    free(res4.data);
    for (int i = 0; i < res5->rows; i++) {
        free(res5->data[i]);
    }
    free(res5->data);
    free(res5);

    return 0;
}